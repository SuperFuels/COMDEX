# ================================================================
# üí° Phase 45G.11 ‚Äî QPhoton Runtime Bridge (QQC Replay Engine)
# ================================================================
"""
Reads a .photo packet generated by QCompiler and replays the
photon instructions through the QuantPy / QQC runtime.

Execution model:
    .photo  ‚Üí parsed ‚Üí dispatch to QTensorField ops
               ‚äï ‚Üí superpose()
               ‚Üî ‚Üí entangle()
               ‚ü≤ ‚Üí resonate()
               ‚àá ‚Üí collapse()
               Œº ‚Üí measure()
               œÄ ‚Üí project()

Outputs:
    data/quantum/qphoton_logs/<session_id>_replay.json
"""

import json, time, logging
from pathlib import Path
from typing import Dict, Any

from backend.quant.qtensor.qtensor_field import random_field, QTensorField

logger = logging.getLogger(__name__)
OUT_DIR = Path("data/quantum/qphoton_logs")
OUT_DIR.mkdir(parents=True, exist_ok=True)


# ----------------------------------------------------------------------
class QPhotonRuntime:
    def __init__(self):
        self.start_time = time.time()
        self.state: QTensorField | None = None
        self.results = []

    # ------------------------------------------------------------------
    def load_packet(self, path: str) -> Dict[str, Any]:
        with open(path, "r") as f:
            packet = json.load(f)
        logger.info(f"[QPhoton] Loaded packet '{path}' with {len(packet.get('instructions', []))} ops.")
        return packet

    # ------------------------------------------------------------------
    def execute(self, packet: Dict[str, Any]):
        """Replay all photon instructions sequentially."""
        self.state = random_field((8, 8))
        for instr in packet.get("instructions", []):
            op = instr["op"]
            if op == "PHOTON_SUPERPOSE":
                self.state = self.state.superpose(random_field((8, 8)))
            elif op == "PHOTON_ENTANGLE":
                a, b, œÅ = self.state.entangle(random_field((8, 8)))
                self.state = a
                self.results.append({"œÅ": œÅ, "op": op})
            elif op == "PHOTON_RESONATE":
                self.state = self.state.resonate()
            elif op == "PHOTON_COLLAPSE":
                collapse = self.state.collapse()
                self.results.append({"mean_intensity": float(collapse.mean()), "op": op})
            elif op == "PHOTON_MEASURE":
                Œº = self.state.measure()
                self.results.append({"measurement": Œº, "op": op})
            else:
                logger.warning(f"[QPhoton] Unknown op {op}")

        logger.info(f"[QPhoton] Executed {len(packet.get('instructions', []))} photon ops.")
        return self.results

    # ------------------------------------------------------------------
    def export_log(self, session_id: str):
        path = OUT_DIR / f"{session_id}_replay.json"
        json.dump({
            "timestamp": time.time(),
            "results": self.results,
        }, open(path, "w"), indent=2)
        logger.info(f"[QPhoton] Exported replay log ‚Üí {path.resolve()}")
        return path


# ----------------------------------------------------------------------
# CLI Entry
# ----------------------------------------------------------------------
if __name__ == "__main__":
    import sys, logging
    logging.basicConfig(level=logging.INFO)
    if len(sys.argv) < 2:
        print("Usage: python -m backend.quant.qphoton.qphoton_runtime <path_to_.photo>")
        sys.exit(1)

    packet_path = sys.argv[1]
    runtime = QPhotonRuntime()
    packet = runtime.load_packet(packet_path)
    runtime.execute(packet)
    runtime.export_log(session_id=Path(packet_path).stem)
    print("‚úÖ Photon replay complete.")