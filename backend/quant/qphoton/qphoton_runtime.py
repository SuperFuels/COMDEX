# ================================================================
# ðŸ’¡ Phase 45G.11 - QPhoton Runtime Bridge (QQC Replay Engine)
# ================================================================
"""
Reads a .photo packet generated by QCompiler and replays the
photon instructions through the QuantPy / QQC runtime.

Execution model:
    .photo  -> parsed -> dispatch to QTensorField ops
               âŠ• -> superpose()
               â†” -> entangle()
               âŸ² -> resonate()
               âˆ‡ -> collapse()
               Î¼ -> measure()
               Ï€ -> project()

Outputs:
    data/quantum/qphoton_logs/<session_id>_replay.json
"""

import json, time, logging
from pathlib import Path
from typing import Dict, Any

from backend.quant.qtensor.qtensor_field import random_field, QTensorField

logger = logging.getLogger(__name__)
OUT_DIR = Path("data/quantum/qphoton_logs")
OUT_DIR.mkdir(parents=True, exist_ok=True)


# ----------------------------------------------------------------------
class QPhotonRuntime:
    def __init__(self):
        self.start_time = time.time()
        self.state: QTensorField | None = None
        self.results = []

    # ------------------------------------------------------------------
    def load_packet(self, path: str) -> Dict[str, Any]:
        with open(path, "r") as f:
            packet = json.load(f)
        logger.info(f"[QPhoton] Loaded packet '{path}' with {len(packet.get('instructions', []))} ops.")
        return packet

    # ------------------------------------------------------------------
    def execute(self, packet: Dict[str, Any]):
        """Replay all photon instructions sequentially."""
        self.state = random_field((8, 8))
        for instr in packet.get("instructions", []):
            op = instr["op"]
            if op == "PHOTON_SUPERPOSE":
                self.state = self.state.superpose(random_field((8, 8)))
            elif op == "PHOTON_ENTANGLE":
                a, b, Ï = self.state.entangle(random_field((8, 8)))
                self.state = a
                self.results.append({"Ï": Ï, "op": op})
            elif op == "PHOTON_RESONATE":
                self.state = self.state.resonate()
            elif op == "PHOTON_COLLAPSE":
                collapse = self.state.collapse()
                self.results.append({"mean_intensity": float(collapse.mean()), "op": op})
            elif op == "PHOTON_MEASURE":
                Î¼ = self.state.measure()
                self.results.append({"measurement": Î¼, "op": op})
            else:
                logger.warning(f"[QPhoton] Unknown op {op}")

        logger.info(f"[QPhoton] Executed {len(packet.get('instructions', []))} photon ops.")
        return self.results

    # ------------------------------------------------------------------
    def export_log(self, session_id: str):
        path = OUT_DIR / f"{session_id}_replay.json"
        json.dump({
            "timestamp": time.time(),
            "results": self.results,
        }, open(path, "w"), indent=2)
        logger.info(f"[QPhoton] Exported replay log -> {path.resolve()}")
        return path


# ----------------------------------------------------------------------
# CLI Entry
# ----------------------------------------------------------------------
if __name__ == "__main__":
    import sys, logging
    logging.basicConfig(level=logging.INFO)
    if len(sys.argv) < 2:
        print("Usage: python -m backend.quant.qphoton.qphoton_runtime <path_to_.photo>")
        sys.exit(1)

    packet_path = sys.argv[1]
    runtime = QPhotonRuntime()
    packet = runtime.load_packet(packet_path)
    runtime.execute(packet)
    runtime.export_log(session_id=Path(packet_path).stem)
    print("âœ… Photon replay complete.")