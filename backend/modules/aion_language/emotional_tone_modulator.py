"""
Emotional Tone Modulator ‚Äî Phase 43C v1.1
-----------------------------------------
Adapts Aion‚Äôs emotional tone based on recent conversation memory
and semantic context.

Now includes expanded tone set:
  calm, analytical, curious, reflective, empathetic,
  confident, uncertain, neutral.

Author: Tessaris Research Group
Date: Phase 43C ‚Äî October 2025
"""

import time, json
from statistics import mode, mean
from pathlib import Path

from backend.modules.aion_language.conversation_memory import MEM
from backend.modules.aion_language.semantic_context_manager import CTX

TONE_PATH = Path("data/context/tone_state.json")

class EmotionalToneModulator:
    def __init__(self):
        self.state = {"tone": "neutral", "confidence": 0.0, "energy": 0.0, "last_update": time.time()}
        self.available_tones = [
            "neutral", "calm", "analytical", "curious",
            "reflective", "empathetic", "confident", "uncertain"
        ]
        print("üé≠ EmotionalToneModulator global instance initialized as TONE")

    def compute_energy(self, emotions):
        """Map emotion distribution to normalized energy (0‚Äì1)."""
        levels = {
            "calm": 0.2,
            "reflective": 0.3,
            "analytical": 0.6,
            "curious": 0.7,
            "empathetic": 0.5,
            "confident": 0.8,
            "uncertain": 0.4,
            "neutral": 0.5
        }
        vals = [levels.get(e, 0.5) for e in emotions]
        return round(mean(vals), 2) if vals else 0.5

    def update(self):
        """Evaluate conversation tone trends and update system state."""
        # ‚úÖ Flexible memory lookup (compatible with current and legacy structures)
        if hasattr(MEM, "events"):
            memory_source = MEM.events
        elif hasattr(MEM, "context"):
            memory_source = MEM.context
        elif hasattr(MEM, "memory_log"):
            memory_source = MEM.memory_log
        else:
            memory_source = []

        # Extract recent emotion states
        emotions = []
        for e in memory_source[-5:]:
            if isinstance(e, dict):
                emotions.append(e.get("emotion_state", "neutral"))

        dominant = "neutral"
        conf = 0.0

        if emotions:
            try:
                from statistics import mode
                dominant = mode(emotions)
                conf = round(emotions.count(dominant) / len(emotions), 2)
            except:
                dominant = emotions[-1]
                conf = 0.4

        energy = self.compute_energy(emotions)

        self.state = {
            "tone": dominant if dominant in self.available_tones else "neutral",
            "confidence": conf,
            "energy": energy,
            "last_update": time.time()
        }

        print(f"[ToneModulator] üé≠ Tone ‚Üí {self.state['tone']} (conf={self.state['confidence']})")
        self._save()
        return self.state

    def adjust_from_reflection(self, reflection: dict):
        """
        Adjusts tone weights dynamically based on the outcome of
        MetaDialogue reflections (self-assessment feedback).

        This function closes the emotional feedback loop by reading
        the latest self-reflection (generated by MetaDialogueEngine)
        and updating the tone, confidence, and energy fields to promote
        adaptive emotional stability.

        Expected reflection structure:
            {
                "comment": "Resonance drift detected; coherence low.",
                "metrics": {
                    "tone": "neutral",
                    "confidence": 0.35,
                    "resonance": 0.25
                }
            }

        Adjustment logic:
            - Low resonance (<0.3): enter calm tone, lower energy/confidence.
            - Low confidence (<0.4): enter analytical tone, slightly raise energy.
            - Stable reflection (>=0.4 resonance): enter reflective tone, reinforce confidence.
        """

        # Validate reflection input
        if not reflection or "metrics" not in reflection:
            print("[ToneModulator] ‚ö†Ô∏è No reflection metrics available for tone adjustment.")
            return self.state

        m = reflection["metrics"]
        tone = m.get("tone", self.state.get("tone", "neutral"))
        conf = float(m.get("confidence", self.state.get("confidence", 0.5)))
        res = float(m.get("resonance", 0.5))
        comment = reflection.get("comment", "").lower()

        # --- Emotional Adaptation Rules ---
        if "drift" in comment or res < 0.3:
            # Low coherence ‚Üí calm response
            self.state["tone"] = "calm"
            self.state["energy"] = max(0.3, self.state.get("energy", 0.5) - 0.1)
            self.state["confidence"] = max(0.2, conf - 0.1)
            msg = "Detected low resonance; entering CALM tone."
        elif "limited" in comment or conf < 0.4:
            # Low confidence ‚Üí analytical focus
            self.state["tone"] = "analytical"
            self.state["energy"] = min(0.7, self.state.get("energy", 0.5) + 0.1)
            self.state["confidence"] = min(0.6, conf + 0.05)
            msg = "Confidence limited; switching to ANALYTICAL tone."
        elif "stable" in comment or res >= 0.4:
            # Stable and coherent ‚Üí reflective tone
            self.state["tone"] = "reflective"
            self.state["energy"] = 0.5
            self.state["confidence"] = min(1.0, conf + 0.2)
            msg = "System stable; reinforcing REFLECTIVE tone."
        else:
            # Default fallback ‚Üí keep same tone
            self.state["tone"] = tone
            msg = "No major change detected; tone maintained."

        # --- State Finalization ---
        self.state["last_update"] = time.time()

        # Save the updated tone state persistently
        try:
            self._save()
        except Exception as e:
            print(f"[ToneModulator] ‚ö†Ô∏è Could not save tone state: {e}")

        # Log transition message
        print(f"[ToneModulator] üé≠ Reflective adjustment ‚Üí {self.state['tone'].upper()} "
            f"(conf={self.state['confidence']:.2f}, energy={self.state['energy']:.2f}) | {msg}")

        return self.state

    def _save(self):
        TONE_PATH.parent.mkdir(parents=True, exist_ok=True)
        with open(TONE_PATH, "w") as f:
            json.dump(self.state, f, indent=2)

# Global instance
try:
    TONE
except NameError:
    TONE = EmotionalToneModulator()