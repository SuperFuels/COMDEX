# ============================================================
# ðŸ§  Lean Integration - Formal Commit Bridge
# File: backend/modules/lean/lean_integration.py
# ============================================================
from __future__ import annotations

import os
import re
import json
import hashlib
from datetime import datetime
from typing import Dict, Any

# âœ… IMPORTANT:
# Put generated artifacts where your batch runner already looks by default.
# LeanAdapter.run_batch() -> default proofs_dir="backend/symatics/proofs"
LEAN_EXPORT_DIR = os.getenv("AION_LEAN_EXPORT_DIR", "backend/symatics/proofs/atoms")


def _sha8(s: str) -> str:
    return hashlib.sha1((s or "").encode("utf-8")).hexdigest()[:8]


def _sanitize_filename(s: str) -> str:
    """Make a safe filename from a ref/id."""
    s = (s or "").strip() or "harmonic_atom"
    s = s.replace(":", "_").replace("@", "_").replace("/", "_").replace("\\", "_")
    s = re.sub(r"[^A-Za-z0-9._-]+", "_", s)
    s = s.strip("_") or "harmonic_atom"
    return s[:120]


def _lean_string(s: Any) -> str:
    """Escape a Python value as a Lean string literal content."""
    txt = "" if s is None else str(s)
    return txt.replace("\\", "\\\\").replace('"', '\\"')


def _emit_lean(atom_ref: Dict[str, Any]) -> str:
    """
    Write a minimal Lean file capturing the committed Harmonic Atom.
    Returns absolute path to the generated .lean file.
    """
    os.makedirs(LEAN_EXPORT_DIR, exist_ok=True)

    ref = atom_ref.get("ref") or "harmonic_atom"
    label = atom_ref.get("label") or ref
    container = atom_ref.get("container_id") or "unknown"

    # Keep floats as telemetry facts, but store deterministic micros for later proofs.
    sqi_f = float(atom_ref.get("sqi", 0.0) or 0.0)
    sqi_micros = int(round(sqi_f * 1_000_000))

    ts = atom_ref.get("timestamp") or datetime.utcnow().isoformat()
    meta = atom_ref.get("meta", {}) or {}
    logic = atom_ref.get("logic")  # optional string (Lean/Codex expression)

    meta_json = json.dumps(meta, ensure_ascii=False)
    logic_txt = "" if logic is None else str(logic)

    # âœ… avoid overwrite: add stable suffix
    base = _sanitize_filename(ref)
    suffix = _sha8(ref + "|" + container + "|" + ts)
    fname = f"{base}.{suffix}.lean"
    path = os.path.join(LEAN_EXPORT_DIR, fname)

    with open(path, "w", encoding="utf-8") as f:
        f.write("-- Auto-generated by Tessaris Lean Commit Bridge\n")
        f.write("import Init\n\n")
        f.write("namespace Tessaris\nnamespace Atoms\n\n")

        # âœ… stable rehydrate fields as defs (KG-friendly)
        f.write(f'def atom_ref       : String := "{_lean_string(ref)}"\n')
        f.write(f'def atom_label     : String := "{_lean_string(label)}"\n')
        f.write(f'def atom_container : String := "{_lean_string(container)}"\n')
        f.write(f'def atom_timestamp : String := "{_lean_string(ts)}"\n')
        f.write(f"def atom_sqi_micros: Int := {sqi_micros}\n")
        f.write(f'def atom_meta_json : String := "{_lean_string(meta_json)}"\n')
        f.write(f'def atom_logic_txt : String := "{_lean_string(logic_txt)}"\n\n')

        # âœ… minimal structure (facts, not proofs)
        f.write("structure HarmonicAtom where\n")
        f.write("  label       : String\n")
        f.write("  sqi_micros  : Int\n")
        f.write("  timestamp   : String\n")
        f.write("  container   : String\n\n")

        f.write("def atom : HarmonicAtom := {\n")
        f.write("  label      := atom_label,\n")
        f.write("  sqi_micros := atom_sqi_micros,\n")
        f.write("  timestamp  := atom_timestamp,\n")
        f.write("  container  := atom_container,\n")
        f.write("}\n\n")

        # âœ… placeholder theorem (always compiles; later you swap this with real theorems)
        f.write("theorem atom_wellFormed : True := by\n")
        f.write("  trivial\n\n")

        f.write("end Atoms\nend Tessaris\n")

    return os.path.abspath(path)


def push_to_lean(atom_ref: Dict[str, Any]) -> Dict[str, Any]:
    """
    Public API used by /api/sci/commit_atom and auto-commit hooks.
    Creates a Lean artifact for the committed Harmonic Atom.

    Returns: { ok, path, module }
    """
    path = _emit_lean(atom_ref)

    # Best-effort module name (only meaningful if LEAN_EXPORT_DIR is on Lean's path)
    rel = os.path.relpath(path, LEAN_EXPORT_DIR)
    mod = os.path.splitext(rel)[0].replace(os.sep, ".")
    return {"ok": True, "path": path, "module": mod}