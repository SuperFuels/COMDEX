# ============================================================
# ðŸ§  Lean Integration â€” Formal Commit Bridge
# File: backend/modules/lean/lean_integration.py
# ============================================================
from __future__ import annotations
import os, re, json
from datetime import datetime
from typing import Dict, Any

# Where we drop generated Lean artifacts
LEAN_EXPORT_DIR = os.getenv("AION_LEAN_EXPORT_DIR", "data/lean/atoms")

def _sanitize_filename(s: str) -> str:
    """Make a safe filename from a ref/id."""
    s = s.replace(":", "_").replace("@", "_").replace("/", "_").replace("\\", "_")
    s = re.sub(r"[^A-Za-z0-9._-]+", "_", s)
    return s.strip("_") or "harmonic_atom"

def _emit_lean(atom_ref: Dict[str, Any]) -> str:
    """
    Write a minimal Lean structure file capturing the committed Harmonic Atom.
    Returns absolute path to the generated .lean file.
    """
    os.makedirs(LEAN_EXPORT_DIR, exist_ok=True)

    ref      = atom_ref.get("ref", "harmonic_atom")
    label    = atom_ref.get("label", ref)
    sqi      = float(atom_ref.get("sqi", 0.0) or 0.0)
    ts       = atom_ref.get("timestamp") or datetime.utcnow().isoformat()
    meta     = atom_ref.get("meta", {})
    logic    = atom_ref.get("logic")  # optional: a Codex/Lean logic string
    container= atom_ref.get("container_id", "unknown")

    fname = _sanitize_filename(ref) + ".lean"
    path  = os.path.join(LEAN_EXPORT_DIR, fname)

    with open(path, "w", encoding="utf-8") as f:
        f.write("-- Auto-generated by SCI Lean Bridge\n")
        f.write(f"-- ref:        {ref}\n")
        f.write(f"-- container:  {container}\n")
        f.write(f"-- timestamp:  {ts}\n")
        if meta:
            f.write(f"-- meta:       {json.dumps(meta, ensure_ascii=False)}\n")
        if logic:
            f.write(f"-- logic:      {logic}\n")
        f.write("\n")
        f.write("structure HarmonicAtom where\n")
        f.write(f"  label     : String := \"{label}\"\n")
        f.write(f"  sqi       : Float  := {sqi}\n")
        f.write(f"  timestamp : String := \"{ts}\"\n")
        f.write("\n")
        # Optional: a stub theorem we can later stitch into a library
        f.write("-- A placeholder theorem tying this atom to a proof context.\n")
        f.write("theorem HarmonicAtom.wellFormed (A : HarmonicAtom) : True := by\n")
        f.write("  trivial\n")

    return os.path.abspath(path)

def push_to_lean(atom_ref: Dict[str, Any]) -> Dict[str, Any]:
    """
    Public API used by /api/sci/commit_atom and auto-commit hooks.
    Creates a Lean artifact for the committed Harmonic Atom.

    Expected keys in atom_ref:
      - ref (str)            unique reference like "HarmonicAtom_1234@container"
      - label (str)          human label
      - sqi (float)          SQI score
      - timestamp (str)      ISO timestamp (optional)
      - container_id (str)   source container
      - logic (str)          optional logic string
      - meta (dict)          optional extra metadata

    Returns: { ok, path, module }
    """
    path = _emit_lean(atom_ref)
    # Heuristic module name (for later use with a Lean project)
    # e.g., data/lean/atoms/HarmonicAtom_â€¦ â†’ Lean module "atoms.HarmonicAtom_â€¦"
    rel  = os.path.relpath(path, LEAN_EXPORT_DIR)
    mod  = os.path.splitext(rel)[0].replace(os.sep, ".")
    return {"ok": True, "path": path, "module": f"atoms.{mod}"}