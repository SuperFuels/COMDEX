"""
📡 glyphnet_ws.py

🛰️ GlyphNet WebSocket Dispatcher for AION & Symbolic Systems
Handles real-time streaming of glyph activity, entanglement, SoulLaw verdicts, and symbolic future paths.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔮 Symbolic Broadcast Engine – Design Rubric
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ Real-Time Glyph Trigger Streaming
✅ ↔ Entanglement & QGlyph Metadata Sync
✅ SoulLaw Verdict Push (⚖️ 🔒 ✅)
✅ Prediction Path Broadcast (🔮 ↗ 🛤️)
✅ WebSocket + Agent Broadcast Hooks
✅ Replay Integration & GHX Embedding Ready
✅ Dream Match + Cost Trace Support
✅ Ethical Signal Injection & Confidence Tags
"""

import asyncio
import logging
from fastapi import WebSocket
from typing import Dict, List, Any, Optional

from backend.modules.codex.glyph_executor import GlyphExecutor
from backend.modules.state.state_manager import state_manager

logger = logging.getLogger(__name__)

# Connected clients
active_connections: List[WebSocket] = []

# Broadcast queue
event_queue: asyncio.Queue = asyncio.Queue()


async def connect(websocket: WebSocket):
    await websocket.accept()
    active_connections.append(websocket)
    await websocket.send_json({
        "type": "status",
        "message": "🛰️ Connected to GlyphNet WebSocket"
    })
    logger.info(f"WebSocket connected: {websocket.client}")


def disconnect(websocket: WebSocket):
    if websocket in active_connections:
        active_connections.remove(websocket)
        logger.info(f"WebSocket disconnected: {websocket.client}")


async def broadcast_event(event: Dict[str, Any]):
    """Enqueue a symbolic event for broadcast."""
    await event_queue.put(event)


async def glyphnet_ws_loop():
    """Async loop that dispatches queued events to all connected clients."""
    while True:
        event = await event_queue.get()
        disconnected = []
        for conn in active_connections:
            try:
                await conn.send_json(event)
            except Exception as e:
                logger.warning(f"WebSocket send error: {e}")
                disconnected.append(conn)
        for conn in disconnected:
            disconnect(conn)


def start_glyphnet_ws_loop():
    """Start the background broadcast loop."""
    asyncio.create_task(glyphnet_ws_loop())


def push_entanglement_update(
    from_id: str,
    to_id: str,
    ghx_projection_id: Optional[str] = None,
    entangled_ids: Optional[List[str]] = None,
    signal_path: Optional[List[str]] = None,
    source_entropy: Optional[str] = None
):
    """Trigger a WebSocket broadcast for ↔ entanglement, with optional GHX metadata."""
    event: Dict[str, Any] = {
        "type": "entanglement_update",
        "from": from_id,
        "to": to_id,
        "symbol": "↔",
    }

    # Optional GHX / signal metadata
    metadata: Dict[str, Any] = {}
    if ghx_projection_id:
        metadata["ghx_projection_id"] = ghx_projection_id
    if entangled_ids:
        metadata["entangled_ids"] = entangled_ids
    if signal_path:
        metadata["signal_path"] = signal_path
    if source_entropy:
        metadata["source_entropy"] = source_entropy

    if metadata:
        event["metadata"] = metadata

    asyncio.create_task(broadcast_event(event))


# 🛰️ Handle incoming WebSocket events
async def handle_glyphnet_event(websocket: WebSocket, msg: Dict[str, Any]):
    if msg.get("event") == "trigger_glyph":
        coords = msg.get("payload", {}).get("coord", "0,0,0")
        x, y, z = map(int, coords.split(","))
        container_id = msg.get("payload", {}).get("container", "default")

        executor = GlyphExecutor(state_manager)
        await executor.trigger_glyph_remotely(
            container_id=container_id,
            x=x,
            y=y,
            z=z,
            source="ws_trigger"
        )


# ✅ SoulLaw verdict broadcast
def stream_soullaw_verdict(verdict: str, glyph: str, context: str = "SoulLaw"):
    """
    Stream a SoulLaw event over WebSocket to live UI.
    verdict: "violation" or "approval"
    """
    try:
        payload = {
            "type": "soullaw_event",
            "verdict": verdict,
            "glyph": glyph,
            "context": context,
            "tags": ["⚖️", "🔒"] if verdict == "violation" else ["⚖️", "✅"]
        }
        asyncio.create_task(broadcast_event(payload))
        logger.info(f"[GlyphNetWS] Streamed SoulLaw {verdict}: {glyph}")
    except Exception as e:
        logger.warning(f"[GlyphNetWS] Failed to stream SoulLaw verdict: {e}")


# ✅ Prediction broadcast stream
def stream_prediction_paths(predictions: List[Dict[str, Any]], container_path: Optional[str] = None):
    """
    Stream prediction paths generated by PredictionEngine over WebSocket.
    """
    try:
        for pred in predictions:
            event = {
                "type": "prediction_path",
                "glyph": pred.get("input_glyph"),
                "predicted": pred.get("predicted_glyph"),
                "confidence": pred.get("confidence"),
                "goal": pred.get("goal"),
                "container": container_path or pred.get("container_path"),
                "tags": ["🔮", "↗", "🛤️"],
                "meta": {
                    "soul_law": pred.get("soul_law_violation"),
                    "dream_match": pred.get("is_dream_pattern"),
                    "cost": pred.get("codex_cost_estimate"),
                    "multiverse": pred.get("multiverse_label"),
                    "reasoning": pred.get("reasoning")
                }
            }
            asyncio.create_task(broadcast_event(event))
        logger.info(f"[GlyphNetWS] Streamed {len(predictions)} prediction paths.")
    except Exception as e:
        logger.warning(f"[GlyphNetWS] Failed to stream prediction paths: {e}")


# ✅ NEW: Cross-Agent KG Fusion Broadcast
def fusion_broadcast(
    node_id: str,
    confidence: float,
    entropy: float,
    source_agent: str,
    entangled_nodes: Optional[List[str]] = None,
    tags: Optional[List[str]] = None,
):
    """
    Broadcasts merged KG node weights + entangled sync across AION agents.
    Triggered by EntanglementFusion for cross-agent KG updates.
    """
    try:
        event: Dict[str, Any] = {
            "type": "fusion_update",
            "node": {
                "id": node_id,
                "confidence": confidence,
                "entropy": entropy,
                "source_agent": source_agent,
            },
            "entangled_nodes": entangled_nodes or [],
            "tags": tags or ["↔", "🌐"],
        }

        asyncio.create_task(broadcast_event(event))
        logger.info(f"[GlyphNetWS] Fusion broadcast: {node_id} ({confidence:.2f}) from {source_agent}")
    except Exception as e:
        logger.warning(f"[GlyphNetWS] Failed fusion_broadcast for {node_id}: {e}")